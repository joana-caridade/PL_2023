Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> S ;
Rule 2     codigo -> codigo S ;
Rule 3     S -> comando
Rule 4     comando -> ESCREVER args
Rule 5     comando -> VAR var_args
Rule 6     comando -> var = arg
Rule 7     comando -> var_operacoes
Rule 8     comando -> PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
Rule 9     comando -> PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
Rule 10    comando -> FUN var ( ) { codigo }
Rule 11    comando -> FUN var ( var_list ) { codigo }
Rule 12    comando -> INVOCAR var ( )
Rule 13    comando -> INVOCAR var ( args )
Rule 14    var_list -> var
Rule 15    var_list -> var_list , var
Rule 16    var_args -> var = arg
Rule 17    var_args -> var_args , var = arg
Rule 18    args -> arg
Rule 19    args -> args , arg
Rule 20    arg -> str
Rule 21    arg -> arith
Rule 22    arg -> variavel
Rule 23    arg -> funcao
Rule 24    funcao -> ENTRADA ( )
Rule 25    funcao -> ALEATORIO ( arith )
Rule 26    arith -> number
Rule 27    arith -> ( number )
Rule 28    variavel -> var
Rule 29    arith -> variavel
Rule 30    arith -> ( variavel )
Rule 31    var_operacoes -> variavel + = arg
Rule 32    var_operacoes -> variavel - = arg
Rule 33    var_operacoes -> variavel + +
Rule 34    var_operacoes -> variavel - -
Rule 35    number -> arith + arith
Rule 36    number -> arith - arith
Rule 37    number -> arith / arith
Rule 38    number -> arith * arith
Rule 39    number -> arith arith
Rule 40    number -> num

Terminals, with rules where they appear

(                    : 10 11 12 13 24 25 27 30
)                    : 10 11 12 13 24 25 27 30
*                    : 38
+                    : 31 33 33 35
,                    : 9 15 17 19
-                    : 32 34 34 36
.                    : 8 8 9 9
/                    : 37
;                    : 1 2
<                    : 8 9
=                    : 6 16 17 31 32
>                    : 8 9
ALEATORIO            : 25
COMMENT              : 
EM                   : 8 9
ENTRADA              : 24
ESCREVER             : 4
FAZER                : 8 9
FIM                  : 8 9
FUN                  : 10 11
INVOCAR              : 12 13
PARA                 : 8 8 9 9
VAR                  : 5
[                    : 8 9
]                    : 8 9
error                : 
num                  : 40
str                  : 20
var                  : 6 8 9 10 11 12 13 14 15 16 17 28
{                    : 10 11
}                    : 10 11

Nonterminals, with rules where they appear

S                    : 1 2
arg                  : 6 8 8 9 9 9 16 17 18 19 31 32
args                 : 4 13 19
arith                : 21 25 35 35 36 36 37 37 38 38 39 39
codigo               : 2 8 9 10 11 0
comando              : 3
funcao               : 23
number               : 26 27
var_args             : 5 17
var_list             : 11 15
var_operacoes        : 7
variavel             : 22 29 30 31 32 33 34

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . S ;
    (2) codigo -> . codigo S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    codigo                         shift and go to state 1
    S                              shift and go to state 2
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 1

    (0) S' -> codigo .
    (2) codigo -> codigo . S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    S                              shift and go to state 12
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 2

    (1) codigo -> S . ;

    ;               shift and go to state 13


state 3

    (3) S -> comando .

    ;               reduce using rule 3 (S -> comando .)


state 4

    (4) comando -> ESCREVER . args
    (18) args -> . arg
    (19) args -> . args , arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    args                           shift and go to state 14
    arg                            shift and go to state 15
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 5

    (5) comando -> VAR . var_args
    (16) var_args -> . var = arg
    (17) var_args -> . var_args , var = arg

    var             shift and go to state 27

    var_args                       shift and go to state 26

state 6

    (6) comando -> var . = arg
    (28) variavel -> var .

    =               shift and go to state 28
    +               reduce using rule 28 (variavel -> var .)
    -               reduce using rule 28 (variavel -> var .)


state 7

    (7) comando -> var_operacoes .

    ;               reduce using rule 7 (comando -> var_operacoes .)


state 8

    (8) comando -> PARA . var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> PARA . var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA

    var             shift and go to state 29


state 9

    (10) comando -> FUN . var ( ) { codigo }
    (11) comando -> FUN . var ( var_list ) { codigo }

    var             shift and go to state 30


state 10

    (12) comando -> INVOCAR . var ( )
    (13) comando -> INVOCAR . var ( args )

    var             shift and go to state 31


state 11

    (31) var_operacoes -> variavel . + = arg
    (32) var_operacoes -> variavel . - = arg
    (33) var_operacoes -> variavel . + +
    (34) var_operacoes -> variavel . - -

    +               shift and go to state 32
    -               shift and go to state 33


state 12

    (2) codigo -> codigo S . ;

    ;               shift and go to state 34


state 13

    (1) codigo -> S ; .

    ESCREVER        reduce using rule 1 (codigo -> S ; .)
    VAR             reduce using rule 1 (codigo -> S ; .)
    var             reduce using rule 1 (codigo -> S ; .)
    PARA            reduce using rule 1 (codigo -> S ; .)
    FUN             reduce using rule 1 (codigo -> S ; .)
    INVOCAR         reduce using rule 1 (codigo -> S ; .)
    $end            reduce using rule 1 (codigo -> S ; .)
    }               reduce using rule 1 (codigo -> S ; .)
    >               reduce using rule 1 (codigo -> S ; .)


state 14

    (4) comando -> ESCREVER args .
    (19) args -> args . , arg

    ;               reduce using rule 4 (comando -> ESCREVER args .)
    ,               shift and go to state 35


state 15

    (18) args -> arg .

    ,               reduce using rule 18 (args -> arg .)
    ;               reduce using rule 18 (args -> arg .)
    )               reduce using rule 18 (args -> arg .)


state 16

    (20) arg -> str .

    ,               reduce using rule 20 (arg -> str .)
    ;               reduce using rule 20 (arg -> str .)
    )               reduce using rule 20 (arg -> str .)
    .               reduce using rule 20 (arg -> str .)
    ]               reduce using rule 20 (arg -> str .)


state 17

    (21) arg -> arith .
    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    ,               reduce using rule 21 (arg -> arith .)
    ;               reduce using rule 21 (arg -> arith .)
    )               reduce using rule 21 (arg -> arith .)
    .               reduce using rule 21 (arg -> arith .)
    ]               reduce using rule 21 (arg -> arith .)
    +               shift and go to state 37
    -               shift and go to state 38
    /               shift and go to state 39
    *               shift and go to state 40
    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 18

    (22) arg -> variavel .
    (29) arith -> variavel .

  ! reduce/reduce conflict for , resolved using rule 22 (arg -> variavel .)
  ! reduce/reduce conflict for ; resolved using rule 22 (arg -> variavel .)
  ! reduce/reduce conflict for ) resolved using rule 22 (arg -> variavel .)
  ! reduce/reduce conflict for . resolved using rule 22 (arg -> variavel .)
  ! reduce/reduce conflict for ] resolved using rule 22 (arg -> variavel .)
    ,               reduce using rule 22 (arg -> variavel .)
    ;               reduce using rule 22 (arg -> variavel .)
    )               reduce using rule 22 (arg -> variavel .)
    .               reduce using rule 22 (arg -> variavel .)
    ]               reduce using rule 22 (arg -> variavel .)
    +               reduce using rule 29 (arith -> variavel .)
    -               reduce using rule 29 (arith -> variavel .)
    /               reduce using rule 29 (arith -> variavel .)
    *               reduce using rule 29 (arith -> variavel .)
    (               reduce using rule 29 (arith -> variavel .)
    num             reduce using rule 29 (arith -> variavel .)
    var             reduce using rule 29 (arith -> variavel .)

  ! ,               [ reduce using rule 29 (arith -> variavel .) ]
  ! ;               [ reduce using rule 29 (arith -> variavel .) ]
  ! )               [ reduce using rule 29 (arith -> variavel .) ]
  ! .               [ reduce using rule 29 (arith -> variavel .) ]
  ! ]               [ reduce using rule 29 (arith -> variavel .) ]


state 19

    (23) arg -> funcao .

    ,               reduce using rule 23 (arg -> funcao .)
    ;               reduce using rule 23 (arg -> funcao .)
    )               reduce using rule 23 (arg -> funcao .)
    .               reduce using rule 23 (arg -> funcao .)
    ]               reduce using rule 23 (arg -> funcao .)


state 20

    (26) arith -> number .

    +               reduce using rule 26 (arith -> number .)
    -               reduce using rule 26 (arith -> number .)
    /               reduce using rule 26 (arith -> number .)
    *               reduce using rule 26 (arith -> number .)
    (               reduce using rule 26 (arith -> number .)
    num             reduce using rule 26 (arith -> number .)
    var             reduce using rule 26 (arith -> number .)
    ,               reduce using rule 26 (arith -> number .)
    ;               reduce using rule 26 (arith -> number .)
    )               reduce using rule 26 (arith -> number .)
    .               reduce using rule 26 (arith -> number .)
    ]               reduce using rule 26 (arith -> number .)


state 21

    (27) arith -> ( . number )
    (30) arith -> ( . variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )

    num             shift and go to state 25
    var             shift and go to state 22
    (               shift and go to state 21

    number                         shift and go to state 42
    variavel                       shift and go to state 43
    arith                          shift and go to state 44

state 22

    (28) variavel -> var .

    ,               reduce using rule 28 (variavel -> var .)
    ;               reduce using rule 28 (variavel -> var .)
    +               reduce using rule 28 (variavel -> var .)
    -               reduce using rule 28 (variavel -> var .)
    /               reduce using rule 28 (variavel -> var .)
    *               reduce using rule 28 (variavel -> var .)
    (               reduce using rule 28 (variavel -> var .)
    num             reduce using rule 28 (variavel -> var .)
    var             reduce using rule 28 (variavel -> var .)
    )               reduce using rule 28 (variavel -> var .)
    .               reduce using rule 28 (variavel -> var .)
    ]               reduce using rule 28 (variavel -> var .)


state 23

    (24) funcao -> ENTRADA . ( )

    (               shift and go to state 45


state 24

    (25) funcao -> ALEATORIO . ( arith )

    (               shift and go to state 46


state 25

    (40) number -> num .

    +               reduce using rule 40 (number -> num .)
    -               reduce using rule 40 (number -> num .)
    /               reduce using rule 40 (number -> num .)
    *               reduce using rule 40 (number -> num .)
    (               reduce using rule 40 (number -> num .)
    num             reduce using rule 40 (number -> num .)
    var             reduce using rule 40 (number -> num .)
    ,               reduce using rule 40 (number -> num .)
    ;               reduce using rule 40 (number -> num .)
    )               reduce using rule 40 (number -> num .)
    .               reduce using rule 40 (number -> num .)
    ]               reduce using rule 40 (number -> num .)


state 26

    (5) comando -> VAR var_args .
    (17) var_args -> var_args . , var = arg

    ;               reduce using rule 5 (comando -> VAR var_args .)
    ,               shift and go to state 47


state 27

    (16) var_args -> var . = arg

    =               shift and go to state 48


state 28

    (6) comando -> var = . arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    arg                            shift and go to state 49
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 29

    (8) comando -> PARA var . EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> PARA var . EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA

    EM              shift and go to state 50


state 30

    (10) comando -> FUN var . ( ) { codigo }
    (11) comando -> FUN var . ( var_list ) { codigo }

    (               shift and go to state 51


state 31

    (12) comando -> INVOCAR var . ( )
    (13) comando -> INVOCAR var . ( args )

    (               shift and go to state 52


state 32

    (31) var_operacoes -> variavel + . = arg
    (33) var_operacoes -> variavel + . +

    =               shift and go to state 54
    +               shift and go to state 53


state 33

    (32) var_operacoes -> variavel - . = arg
    (34) var_operacoes -> variavel - . -

    =               shift and go to state 56
    -               shift and go to state 55


state 34

    (2) codigo -> codigo S ; .

    ESCREVER        reduce using rule 2 (codigo -> codigo S ; .)
    VAR             reduce using rule 2 (codigo -> codigo S ; .)
    var             reduce using rule 2 (codigo -> codigo S ; .)
    PARA            reduce using rule 2 (codigo -> codigo S ; .)
    FUN             reduce using rule 2 (codigo -> codigo S ; .)
    INVOCAR         reduce using rule 2 (codigo -> codigo S ; .)
    $end            reduce using rule 2 (codigo -> codigo S ; .)
    }               reduce using rule 2 (codigo -> codigo S ; .)
    >               reduce using rule 2 (codigo -> codigo S ; .)


state 35

    (19) args -> args , . arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    arg                            shift and go to state 57
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 36

    (39) number -> arith arith .
    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for num resolved as shift
  ! shift/reduce conflict for var resolved as shift
    ,               reduce using rule 39 (number -> arith arith .)
    ;               reduce using rule 39 (number -> arith arith .)
    )               reduce using rule 39 (number -> arith arith .)
    .               reduce using rule 39 (number -> arith arith .)
    ]               reduce using rule 39 (number -> arith arith .)
    +               shift and go to state 37
    -               shift and go to state 38
    /               shift and go to state 39
    *               shift and go to state 40
    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

  ! +               [ reduce using rule 39 (number -> arith arith .) ]
  ! -               [ reduce using rule 39 (number -> arith arith .) ]
  ! /               [ reduce using rule 39 (number -> arith arith .) ]
  ! *               [ reduce using rule 39 (number -> arith arith .) ]
  ! (               [ reduce using rule 39 (number -> arith arith .) ]
  ! num             [ reduce using rule 39 (number -> arith arith .) ]
  ! var             [ reduce using rule 39 (number -> arith arith .) ]

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 37

    (35) number -> arith + . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 58
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 38

    (36) number -> arith - . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 59
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 39

    (37) number -> arith / . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 60
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 40

    (38) number -> arith * . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 61
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 41

    (29) arith -> variavel .

    +               reduce using rule 29 (arith -> variavel .)
    -               reduce using rule 29 (arith -> variavel .)
    /               reduce using rule 29 (arith -> variavel .)
    *               reduce using rule 29 (arith -> variavel .)
    (               reduce using rule 29 (arith -> variavel .)
    num             reduce using rule 29 (arith -> variavel .)
    var             reduce using rule 29 (arith -> variavel .)
    ,               reduce using rule 29 (arith -> variavel .)
    ;               reduce using rule 29 (arith -> variavel .)
    )               reduce using rule 29 (arith -> variavel .)
    .               reduce using rule 29 (arith -> variavel .)
    ]               reduce using rule 29 (arith -> variavel .)


state 42

    (27) arith -> ( number . )
    (26) arith -> number .

    )               shift and go to state 62
    +               reduce using rule 26 (arith -> number .)
    -               reduce using rule 26 (arith -> number .)
    /               reduce using rule 26 (arith -> number .)
    *               reduce using rule 26 (arith -> number .)
    (               reduce using rule 26 (arith -> number .)
    num             reduce using rule 26 (arith -> number .)
    var             reduce using rule 26 (arith -> number .)


state 43

    (30) arith -> ( variavel . )
    (29) arith -> variavel .

    )               shift and go to state 63
    +               reduce using rule 29 (arith -> variavel .)
    -               reduce using rule 29 (arith -> variavel .)
    /               reduce using rule 29 (arith -> variavel .)
    *               reduce using rule 29 (arith -> variavel .)
    (               reduce using rule 29 (arith -> variavel .)
    num             reduce using rule 29 (arith -> variavel .)
    var             reduce using rule 29 (arith -> variavel .)


state 44

    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    +               shift and go to state 37
    -               shift and go to state 38
    /               shift and go to state 39
    *               shift and go to state 40
    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 45

    (24) funcao -> ENTRADA ( . )

    )               shift and go to state 64


state 46

    (25) funcao -> ALEATORIO ( . arith )
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 65
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 47

    (17) var_args -> var_args , . var = arg

    var             shift and go to state 66


state 48

    (16) var_args -> var = . arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    arg                            shift and go to state 67
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 49

    (6) comando -> var = arg .

    ;               reduce using rule 6 (comando -> var = arg .)


state 50

    (8) comando -> PARA var EM . [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> PARA var EM . [ arg . . arg , arg ] FAZER < codigo > FIM PARA

    [               shift and go to state 68


state 51

    (10) comando -> FUN var ( . ) { codigo }
    (11) comando -> FUN var ( . var_list ) { codigo }
    (14) var_list -> . var
    (15) var_list -> . var_list , var

    )               shift and go to state 70
    var             shift and go to state 69

    var_list                       shift and go to state 71

state 52

    (12) comando -> INVOCAR var ( . )
    (13) comando -> INVOCAR var ( . args )
    (18) args -> . arg
    (19) args -> . args , arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    )               shift and go to state 72
    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    args                           shift and go to state 73
    arg                            shift and go to state 15
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 53

    (33) var_operacoes -> variavel + + .

    ;               reduce using rule 33 (var_operacoes -> variavel + + .)


state 54

    (31) var_operacoes -> variavel + = . arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    variavel                       shift and go to state 18
    arg                            shift and go to state 74
    arith                          shift and go to state 17
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 55

    (34) var_operacoes -> variavel - - .

    ;               reduce using rule 34 (var_operacoes -> variavel - - .)


state 56

    (32) var_operacoes -> variavel - = . arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    variavel                       shift and go to state 18
    arg                            shift and go to state 75
    arith                          shift and go to state 17
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 57

    (19) args -> args , arg .

    ,               reduce using rule 19 (args -> args , arg .)
    ;               reduce using rule 19 (args -> args , arg .)
    )               reduce using rule 19 (args -> args , arg .)


state 58

    (35) number -> arith + arith .
    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    +               reduce using rule 35 (number -> arith + arith .)
    -               reduce using rule 35 (number -> arith + arith .)
    num             reduce using rule 35 (number -> arith + arith .)
    var             reduce using rule 35 (number -> arith + arith .)
    ,               reduce using rule 35 (number -> arith + arith .)
    ;               reduce using rule 35 (number -> arith + arith .)
    )               reduce using rule 35 (number -> arith + arith .)
    .               reduce using rule 35 (number -> arith + arith .)
    ]               reduce using rule 35 (number -> arith + arith .)
    /               shift and go to state 39
    *               shift and go to state 40
    (               shift and go to state 21

  ! /               [ reduce using rule 35 (number -> arith + arith .) ]
  ! *               [ reduce using rule 35 (number -> arith + arith .) ]
  ! (               [ reduce using rule 35 (number -> arith + arith .) ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! num             [ shift and go to state 25 ]
  ! var             [ shift and go to state 22 ]

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 59

    (36) number -> arith - arith .
    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    +               reduce using rule 36 (number -> arith - arith .)
    -               reduce using rule 36 (number -> arith - arith .)
    num             reduce using rule 36 (number -> arith - arith .)
    var             reduce using rule 36 (number -> arith - arith .)
    ,               reduce using rule 36 (number -> arith - arith .)
    ;               reduce using rule 36 (number -> arith - arith .)
    )               reduce using rule 36 (number -> arith - arith .)
    .               reduce using rule 36 (number -> arith - arith .)
    ]               reduce using rule 36 (number -> arith - arith .)
    /               shift and go to state 39
    *               shift and go to state 40
    (               shift and go to state 21

  ! /               [ reduce using rule 36 (number -> arith - arith .) ]
  ! *               [ reduce using rule 36 (number -> arith - arith .) ]
  ! (               [ reduce using rule 36 (number -> arith - arith .) ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! num             [ shift and go to state 25 ]
  ! var             [ shift and go to state 22 ]

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 60

    (37) number -> arith / arith .
    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    +               reduce using rule 37 (number -> arith / arith .)
    -               reduce using rule 37 (number -> arith / arith .)
    /               reduce using rule 37 (number -> arith / arith .)
    *               reduce using rule 37 (number -> arith / arith .)
    num             reduce using rule 37 (number -> arith / arith .)
    var             reduce using rule 37 (number -> arith / arith .)
    ,               reduce using rule 37 (number -> arith / arith .)
    ;               reduce using rule 37 (number -> arith / arith .)
    )               reduce using rule 37 (number -> arith / arith .)
    .               reduce using rule 37 (number -> arith / arith .)
    ]               reduce using rule 37 (number -> arith / arith .)
    (               shift and go to state 21

  ! (               [ reduce using rule 37 (number -> arith / arith .) ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! /               [ shift and go to state 39 ]
  ! *               [ shift and go to state 40 ]
  ! num             [ shift and go to state 25 ]
  ! var             [ shift and go to state 22 ]

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 61

    (38) number -> arith * arith .
    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    +               reduce using rule 38 (number -> arith * arith .)
    -               reduce using rule 38 (number -> arith * arith .)
    /               reduce using rule 38 (number -> arith * arith .)
    *               reduce using rule 38 (number -> arith * arith .)
    num             reduce using rule 38 (number -> arith * arith .)
    var             reduce using rule 38 (number -> arith * arith .)
    ,               reduce using rule 38 (number -> arith * arith .)
    ;               reduce using rule 38 (number -> arith * arith .)
    )               reduce using rule 38 (number -> arith * arith .)
    .               reduce using rule 38 (number -> arith * arith .)
    ]               reduce using rule 38 (number -> arith * arith .)
    (               shift and go to state 21

  ! (               [ reduce using rule 38 (number -> arith * arith .) ]
  ! +               [ shift and go to state 37 ]
  ! -               [ shift and go to state 38 ]
  ! /               [ shift and go to state 39 ]
  ! *               [ shift and go to state 40 ]
  ! num             [ shift and go to state 25 ]
  ! var             [ shift and go to state 22 ]

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 62

    (27) arith -> ( number ) .

    +               reduce using rule 27 (arith -> ( number ) .)
    -               reduce using rule 27 (arith -> ( number ) .)
    /               reduce using rule 27 (arith -> ( number ) .)
    *               reduce using rule 27 (arith -> ( number ) .)
    (               reduce using rule 27 (arith -> ( number ) .)
    num             reduce using rule 27 (arith -> ( number ) .)
    var             reduce using rule 27 (arith -> ( number ) .)
    ,               reduce using rule 27 (arith -> ( number ) .)
    ;               reduce using rule 27 (arith -> ( number ) .)
    )               reduce using rule 27 (arith -> ( number ) .)
    .               reduce using rule 27 (arith -> ( number ) .)
    ]               reduce using rule 27 (arith -> ( number ) .)


state 63

    (30) arith -> ( variavel ) .

    +               reduce using rule 30 (arith -> ( variavel ) .)
    -               reduce using rule 30 (arith -> ( variavel ) .)
    /               reduce using rule 30 (arith -> ( variavel ) .)
    *               reduce using rule 30 (arith -> ( variavel ) .)
    (               reduce using rule 30 (arith -> ( variavel ) .)
    num             reduce using rule 30 (arith -> ( variavel ) .)
    var             reduce using rule 30 (arith -> ( variavel ) .)
    ,               reduce using rule 30 (arith -> ( variavel ) .)
    ;               reduce using rule 30 (arith -> ( variavel ) .)
    )               reduce using rule 30 (arith -> ( variavel ) .)
    .               reduce using rule 30 (arith -> ( variavel ) .)
    ]               reduce using rule 30 (arith -> ( variavel ) .)


state 64

    (24) funcao -> ENTRADA ( ) .

    ,               reduce using rule 24 (funcao -> ENTRADA ( ) .)
    ;               reduce using rule 24 (funcao -> ENTRADA ( ) .)
    )               reduce using rule 24 (funcao -> ENTRADA ( ) .)
    .               reduce using rule 24 (funcao -> ENTRADA ( ) .)
    ]               reduce using rule 24 (funcao -> ENTRADA ( ) .)


state 65

    (25) funcao -> ALEATORIO ( arith . )
    (35) number -> arith . + arith
    (36) number -> arith . - arith
    (37) number -> arith . / arith
    (38) number -> arith . * arith
    (39) number -> arith . arith
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num
    (28) variavel -> . var

    )               shift and go to state 76
    +               shift and go to state 37
    -               shift and go to state 38
    /               shift and go to state 39
    *               shift and go to state 40
    (               shift and go to state 21
    num             shift and go to state 25
    var             shift and go to state 22

    arith                          shift and go to state 36
    number                         shift and go to state 20
    variavel                       shift and go to state 41

state 66

    (17) var_args -> var_args , var . = arg

    =               shift and go to state 77


state 67

    (16) var_args -> var = arg .

    ,               reduce using rule 16 (var_args -> var = arg .)
    ;               reduce using rule 16 (var_args -> var = arg .)


state 68

    (8) comando -> PARA var EM [ . arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> PARA var EM [ . arg . . arg , arg ] FAZER < codigo > FIM PARA
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    arg                            shift and go to state 78
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 69

    (14) var_list -> var .

    )               reduce using rule 14 (var_list -> var .)
    ,               reduce using rule 14 (var_list -> var .)


state 70

    (10) comando -> FUN var ( ) . { codigo }

    {               shift and go to state 79


state 71

    (11) comando -> FUN var ( var_list . ) { codigo }
    (15) var_list -> var_list . , var

    )               shift and go to state 80
    ,               shift and go to state 81


state 72

    (12) comando -> INVOCAR var ( ) .

    ;               reduce using rule 12 (comando -> INVOCAR var ( ) .)


state 73

    (13) comando -> INVOCAR var ( args . )
    (19) args -> args . , arg

    )               shift and go to state 82
    ,               shift and go to state 35


state 74

    (31) var_operacoes -> variavel + = arg .

    ;               reduce using rule 31 (var_operacoes -> variavel + = arg .)


state 75

    (32) var_operacoes -> variavel - = arg .

    ;               reduce using rule 32 (var_operacoes -> variavel - = arg .)


state 76

    (25) funcao -> ALEATORIO ( arith ) .

    ,               reduce using rule 25 (funcao -> ALEATORIO ( arith ) .)
    ;               reduce using rule 25 (funcao -> ALEATORIO ( arith ) .)
    )               reduce using rule 25 (funcao -> ALEATORIO ( arith ) .)
    .               reduce using rule 25 (funcao -> ALEATORIO ( arith ) .)
    ]               reduce using rule 25 (funcao -> ALEATORIO ( arith ) .)


state 77

    (17) var_args -> var_args , var = . arg
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    arg                            shift and go to state 83
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 78

    (8) comando -> PARA var EM [ arg . . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> PARA var EM [ arg . . . arg , arg ] FAZER < codigo > FIM PARA

    .               shift and go to state 84


state 79

    (10) comando -> FUN var ( ) { . codigo }
    (1) codigo -> . S ;
    (2) codigo -> . codigo S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    codigo                         shift and go to state 85
    S                              shift and go to state 2
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 80

    (11) comando -> FUN var ( var_list ) . { codigo }

    {               shift and go to state 86


state 81

    (15) var_list -> var_list , . var

    var             shift and go to state 87


state 82

    (13) comando -> INVOCAR var ( args ) .

    ;               reduce using rule 13 (comando -> INVOCAR var ( args ) .)


state 83

    (17) var_args -> var_args , var = arg .

    ,               reduce using rule 17 (var_args -> var_args , var = arg .)
    ;               reduce using rule 17 (var_args -> var_args , var = arg .)


state 84

    (8) comando -> PARA var EM [ arg . . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> PARA var EM [ arg . . . arg , arg ] FAZER < codigo > FIM PARA

    .               shift and go to state 88


state 85

    (10) comando -> FUN var ( ) { codigo . }
    (2) codigo -> codigo . S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    }               shift and go to state 89
    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    S                              shift and go to state 12
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 86

    (11) comando -> FUN var ( var_list ) { . codigo }
    (1) codigo -> . S ;
    (2) codigo -> . codigo S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    codigo                         shift and go to state 90
    S                              shift and go to state 2
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 87

    (15) var_list -> var_list , var .

    )               reduce using rule 15 (var_list -> var_list , var .)
    ,               reduce using rule 15 (var_list -> var_list , var .)


state 88

    (8) comando -> PARA var EM [ arg . . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> PARA var EM [ arg . . . arg , arg ] FAZER < codigo > FIM PARA
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    arg                            shift and go to state 91
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 89

    (10) comando -> FUN var ( ) { codigo } .

    ;               reduce using rule 10 (comando -> FUN var ( ) { codigo } .)


state 90

    (11) comando -> FUN var ( var_list ) { codigo . }
    (2) codigo -> codigo . S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    }               shift and go to state 92
    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    S                              shift and go to state 12
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 91

    (8) comando -> PARA var EM [ arg . . arg . ] FAZER < codigo > FIM PARA
    (9) comando -> PARA var EM [ arg . . arg . , arg ] FAZER < codigo > FIM PARA

    ]               shift and go to state 93
    ,               shift and go to state 94


state 92

    (11) comando -> FUN var ( var_list ) { codigo } .

    ;               reduce using rule 11 (comando -> FUN var ( var_list ) { codigo } .)


state 93

    (8) comando -> PARA var EM [ arg . . arg ] . FAZER < codigo > FIM PARA

    FAZER           shift and go to state 95


state 94

    (9) comando -> PARA var EM [ arg . . arg , . arg ] FAZER < codigo > FIM PARA
    (20) arg -> . str
    (21) arg -> . arith
    (22) arg -> . variavel
    (23) arg -> . funcao
    (26) arith -> . number
    (27) arith -> . ( number )
    (29) arith -> . variavel
    (30) arith -> . ( variavel )
    (28) variavel -> . var
    (24) funcao -> . ENTRADA ( )
    (25) funcao -> . ALEATORIO ( arith )
    (35) number -> . arith + arith
    (36) number -> . arith - arith
    (37) number -> . arith / arith
    (38) number -> . arith * arith
    (39) number -> . arith arith
    (40) number -> . num

    str             shift and go to state 16
    (               shift and go to state 21
    var             shift and go to state 22
    ENTRADA         shift and go to state 23
    ALEATORIO       shift and go to state 24
    num             shift and go to state 25

    arg                            shift and go to state 96
    arith                          shift and go to state 17
    variavel                       shift and go to state 18
    funcao                         shift and go to state 19
    number                         shift and go to state 20

state 95

    (8) comando -> PARA var EM [ arg . . arg ] FAZER . < codigo > FIM PARA

    <               shift and go to state 97


state 96

    (9) comando -> PARA var EM [ arg . . arg , arg . ] FAZER < codigo > FIM PARA

    ]               shift and go to state 98


state 97

    (8) comando -> PARA var EM [ arg . . arg ] FAZER < . codigo > FIM PARA
    (1) codigo -> . S ;
    (2) codigo -> . codigo S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    codigo                         shift and go to state 99
    S                              shift and go to state 2
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 98

    (9) comando -> PARA var EM [ arg . . arg , arg ] . FAZER < codigo > FIM PARA

    FAZER           shift and go to state 100


state 99

    (8) comando -> PARA var EM [ arg . . arg ] FAZER < codigo . > FIM PARA
    (2) codigo -> codigo . S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    >               shift and go to state 101
    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    S                              shift and go to state 12
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 100

    (9) comando -> PARA var EM [ arg . . arg , arg ] FAZER . < codigo > FIM PARA

    <               shift and go to state 102


state 101

    (8) comando -> PARA var EM [ arg . . arg ] FAZER < codigo > . FIM PARA

    FIM             shift and go to state 103


state 102

    (9) comando -> PARA var EM [ arg . . arg , arg ] FAZER < . codigo > FIM PARA
    (1) codigo -> . S ;
    (2) codigo -> . codigo S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    codigo                         shift and go to state 104
    S                              shift and go to state 2
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 103

    (8) comando -> PARA var EM [ arg . . arg ] FAZER < codigo > FIM . PARA

    PARA            shift and go to state 105


state 104

    (9) comando -> PARA var EM [ arg . . arg , arg ] FAZER < codigo . > FIM PARA
    (2) codigo -> codigo . S ;
    (3) S -> . comando
    (4) comando -> . ESCREVER args
    (5) comando -> . VAR var_args
    (6) comando -> . var = arg
    (7) comando -> . var_operacoes
    (8) comando -> . PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA
    (9) comando -> . PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA
    (10) comando -> . FUN var ( ) { codigo }
    (11) comando -> . FUN var ( var_list ) { codigo }
    (12) comando -> . INVOCAR var ( )
    (13) comando -> . INVOCAR var ( args )
    (31) var_operacoes -> . variavel + = arg
    (32) var_operacoes -> . variavel - = arg
    (33) var_operacoes -> . variavel + +
    (34) var_operacoes -> . variavel - -
    (28) variavel -> . var

    >               shift and go to state 106
    ESCREVER        shift and go to state 4
    VAR             shift and go to state 5
    var             shift and go to state 6
    PARA            shift and go to state 8
    FUN             shift and go to state 9
    INVOCAR         shift and go to state 10

    S                              shift and go to state 12
    comando                        shift and go to state 3
    var_operacoes                  shift and go to state 7
    variavel                       shift and go to state 11

state 105

    (8) comando -> PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA .

    ;               reduce using rule 8 (comando -> PARA var EM [ arg . . arg ] FAZER < codigo > FIM PARA .)


state 106

    (9) comando -> PARA var EM [ arg . . arg , arg ] FAZER < codigo > . FIM PARA

    FIM             shift and go to state 107


state 107

    (9) comando -> PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM . PARA

    PARA            shift and go to state 108


state 108

    (9) comando -> PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA .

    ;               reduce using rule 9 (comando -> PARA var EM [ arg . . arg , arg ] FAZER < codigo > FIM PARA .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 36 resolved as shift
WARNING: shift/reduce conflict for - in state 36 resolved as shift
WARNING: shift/reduce conflict for / in state 36 resolved as shift
WARNING: shift/reduce conflict for * in state 36 resolved as shift
WARNING: shift/reduce conflict for ( in state 36 resolved as shift
WARNING: shift/reduce conflict for num in state 36 resolved as shift
WARNING: shift/reduce conflict for var in state 36 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (arg -> variavel)
WARNING: rejected rule (arith -> variavel) in state 18
